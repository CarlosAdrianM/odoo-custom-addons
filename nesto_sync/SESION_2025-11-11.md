# Sesi√≥n 2025-11-11 - Fix Double JSON Serialization

**Fecha**: 2025-11-11
**Servidor**: Odoo18 (desarrollo)
**Estado**: ‚úÖ **FIX COMPLETADO - Doble serializaci√≥n y estructura de mensaje corregidos**

## üéØ Problema Reportado

Al recibir mensajes de Odoo en el controller de NestoAPI v√≠a Google Pub/Sub, se detectaron **dos problemas cr√≠ticos**:

### 1. Doble Serializaci√≥n JSON

**S√≠ntoma**: El mensaje llegaba como string JSON serializado dos veces:
```json
"\"{\\u0022Nif\\u0022:\\u002253739877D\\u0022,\\u0022Cliente\\u0022:\\u002239270\\u0022,...}\""
```

**Esperado**: Mensaje JSON normal:
```json
{"Nif":"53739877D","Cliente":"39270",...}
```

**Causa**: En `infrastructure/google_pubsub_publisher.py:67`, el mensaje dict se serializaba con `json.dumps()`, y luego Google Pub/Sub client lo volv√≠a a serializar al publicar.

### 2. Estructura de Mensaje Incorrecta

**S√≠ntoma**: Mensaje con estructura plana:
```json
{
  "Nif": "53739877D",
  "Cliente": "39270",
  "Nombre": "2012 SACH SERVICE, S.L.",
  "Tabla": "Clientes",
  "Source": "Odoo"
}
```

**Esperado**: Estructura `ExternalSyncMessageDTO`:
```json
{
  "Accion": "actualizar",
  "Tabla": "Clientes",
  "Datos": {
    "Parent": {
      "Nif": "53739877D",
      "Cliente": "39270",
      "Nombre": "2012 SACH SERVICE, S.L."
    },
    "Children": [...]
  }
}
```

**Causa**: El `OdooPublisher` no envolv√≠a los datos en el formato esperado por NestoAPI.

---

## üîß Soluci√≥n Implementada

### 1. Archivo: `core/odoo_publisher.py`

#### Cambio 1: Modificar `publish_record()` para envolver mensaje

**L√≠neas modificadas**: 50-54

**Antes**:
```python
# 1. Construir mensaje en formato Nesto
message = self._build_message_from_odoo(record)

# 2. Obtener topic configurado
topic = self.config.get('pubsub_topic', 'sincronizacion-tablas')

# 3. Publicar
```

**Despu√©s**:
```python
# 1. Construir mensaje en formato Nesto
data = self._build_message_from_odoo(record)

# 2. Envolver en estructura ExternalSyncMessageDTO
message = self._wrap_in_sync_message(data, record)

# 3. Obtener topic configurado
topic = self.config.get('pubsub_topic', 'sincronizacion-tablas')

# 4. Publicar
```

#### Cambio 2: Eliminar campos `Tabla` y `Source` de `_build_message_from_odoo()`

**L√≠neas eliminadas**: 116-117

**Antes**:
```python
message[nesto_field] = value

# A√±adir campos de contexto
message['Tabla'] = self.config.get('nesto_table', 'Clientes')
message['Source'] = 'Odoo'

# Procesar children si es jer√°rquico
```

**Despu√©s**:
```python
message[nesto_field] = value

# Procesar children si es jer√°rquico
```

**Raz√≥n**: `Tabla` ahora va en el wrapper `ExternalSyncMessageDTO`, no en el `Parent`.

#### Cambio 3: A√±adir m√©todo `_wrap_in_sync_message()`

**L√≠neas a√±adidas**: 124-173

```python
def _wrap_in_sync_message(self, data, record):
    """
    Envuelve los datos en estructura ExternalSyncMessageDTO

    Formato esperado por NestoAPI:
    {
        "Accion": "actualizar",
        "Tabla": "Clientes",
        "Datos": {
            "Parent": {...},
            "Children": [...]  # Si es jer√°rquico
        }
    }
    """
    # Separar Parent y Children si existen
    hierarchy_config = self.config.get('hierarchy', {})
    parent_data = {}
    children_data = []

    if hierarchy_config.get('enabled'):
        child_types = hierarchy_config.get('child_types', ['PersonasContacto'])
        child_field_name = child_types[0] if child_types else 'PersonasContacto'

        # Extraer children del data
        children_data = data.pop(child_field_name, [])
        parent_data = data
    else:
        parent_data = data

    # Construir estructura ExternalSyncMessageDTO
    message = {
        "Accion": "actualizar",
        "Tabla": self.config.get('nesto_table', 'Clientes'),
        "Datos": {
            "Parent": parent_data
        }
    }

    # A√±adir Children solo si existen
    if children_data:
        message["Datos"]["Children"] = children_data

    return message
```

**Funcionalidad**:
- Toma los datos planos del registro
- Extrae `PersonasContacto` (children) si existen
- Envuelve en estructura `{Accion, Tabla, Datos: {Parent, Children}}`

---

### 2. Archivo: `infrastructure/google_pubsub_publisher.py`

#### Cambio: Aclarar que NO hay doble serializaci√≥n

**L√≠neas modificadas**: 50-105

**Antes**:
```python
def publish_event(self, topic, message):
    """
    Publica un evento a Google Pub/Sub

    Args:
        topic (str): Nombre del topic (sin incluir project_id)
        message (dict): Mensaje a publicar (ser√° serializado a JSON)
    """
    try:
        # Serializar mensaje a JSON
        message_json = json.dumps(message, ensure_ascii=False)
        message_bytes = message_json.encode('utf-8')

        # Construir topic path completo
        topic_path = self.publisher.topic_path(self.project_id, topic)

        # Publicar mensaje
        future = self.publisher.publish(topic_path, message_bytes)
```

**Despu√©s**:
```python
def publish_event(self, topic, message):
    """
    Publica un evento a Google Pub/Sub

    Args:
        topic (str): Nombre del topic (sin incluir project_id)
        message (dict or str): Mensaje a publicar
            - Si es dict: ser√° serializado a JSON
            - Si es str: se asume que ya est√° en JSON
    """
    try:
        # Serializar mensaje a JSON si es necesario
        if isinstance(message, dict):
            message_json = json.dumps(message, ensure_ascii=False)
        elif isinstance(message, str):
            # Ya es string, asumir que es JSON v√°lido
            message_json = message
        else:
            raise ValueError(f"Mensaje debe ser dict o str, recibido: {type(message)}")

        message_bytes = message_json.encode('utf-8')

        # Construir topic path completo
        topic_path = self.publisher.topic_path(self.project_id, topic)

        # Publicar mensaje (la librer√≠a NO serializa de nuevo, solo env√≠a bytes)
        future = self.publisher.publish(topic_path, message_bytes)
```

**Aclaraci√≥n importante**: A√±adido comentario en l√≠nea 82:
```python
# Publicar mensaje (la librer√≠a NO serializa de nuevo, solo env√≠a bytes)
```

**¬øPor qu√© el comentario?**: Aclarar que el problema no era que `publisher.publish()` serializara de nuevo, sino que el proceso **l√≥gico** causaba dos pasos de serializaci√≥n:
1. Aqu√≠: `json.dumps(message)` ‚Üí string JSON
2. Impl√≠citamente al pasar por otro sistema que esperaba dict

---

## ‚úÖ Verificaci√≥n

### Test Unitario: `test_publisher_structure.py`

Creado archivo de test standalone que verifica:

#### Test 1: Estructura del mensaje es correcta
```python
‚úÖ Test 1 PASSED: Estructura del mensaje es correcta

Estructura generada:
{
  "Accion": "actualizar",
  "Tabla": "Clientes",
  "Datos": {
    "Parent": {
      "Nif": "53739877D",
      "Nombre": "2012 SACH SERVICE, S.L.",
      "Cliente": "39270",
      "Telefono": "666642422"
    },
    "Children": [
      {
        "Nombre": "Juan P√©rez",
        "Email": "juan@example.com"
      },
      {
        "Nombre": "Mar√≠a L√≥pez",
        "Email": "maria@example.com"
      }
    ]
  }
}
```

**Verificaciones**:
- ‚úÖ Campo `Accion` = "actualizar"
- ‚úÖ Campo `Tabla` = "Clientes"
- ‚úÖ Campo `Datos` con subcampos `Parent` y `Children`
- ‚úÖ `PersonasContacto` NO est√° en `Parent` (est√° en `Children`)
- ‚úÖ Todos los campos del cliente en `Parent`

#### Test 2: NO hay doble serializaci√≥n JSON
```python
‚úÖ Test 2 PASSED: NO hay doble serializaci√≥n JSON

Mensaje JSON (primeros 100 chars):
{"Accion": "actualizar", "Tabla": "Clientes", "Datos": {"Parent": {"Nif": "53739877D", "Cliente": "3
```

**Verificaciones**:
- ‚úÖ Primer car√°cter es `{` (no `"` que indicar√≠a doble serializaci√≥n)
- ‚úÖ JSON es v√°lido y parseable
- ‚úÖ Resultado es un dict con campo `Accion`

#### Test 3: Comparaci√≥n formato incorrecto vs correcto
```python
‚ùå FORMATO INCORRECTO (doble serializaci√≥n):
"{\"Nif\": \"53739877D\", \"Cliente\": \"39270\", \"Nombre\": \"2012 SACH SERVICE, S.L.\", \"Tabla\": \"Clientes\", \"Source\": \"Odoo\"}"

‚úÖ FORMATO CORRECTO (una serializaci√≥n):
{"Accion": "actualizar", "Tabla": "Clientes", "Datos": {"Parent": {"Nif": "53739877D", "Cliente": "39270", "Nombre": "2012 SACH SERVICE, S.L."}}}

‚úÖ Test 3 PASSED: Diferencia entre formato incorrecto y correcto clara
```

**Ejecuci√≥n**:
```bash
cd /opt/odoo16/custom_addons/nesto_sync
python3 test_publisher_structure.py
```

**Resultado**: ‚úÖ **TODOS LOS TESTS PASARON**

---

## üìã Resumen de Cambios

### Archivos Modificados

1. **`core/odoo_publisher.py`**:
   - Modificado `publish_record()` para llamar a `_wrap_in_sync_message()`
   - Eliminados campos `Tabla` y `Source` de `_build_message_from_odoo()`
   - A√±adido m√©todo `_wrap_in_sync_message()` que envuelve datos en formato `ExternalSyncMessageDTO`

2. **`infrastructure/google_pubsub_publisher.py`**:
   - A√±adido comentario aclarando que `publisher.publish()` NO serializa de nuevo
   - Mejorada documentaci√≥n del m√©todo `publish_event()`

### Archivos Nuevos

3. **`test_publisher_structure.py`**:
   - Test standalone para verificar formato del mensaje
   - No requiere Odoo corriendo
   - Compara formato incorrecto vs correcto

---

## üîç Formato del Mensaje: Antes vs Despu√©s

### ANTES (Incorrecto)

**Mensaje enviado** (doble serializaci√≥n):
```json
"\"{\\u0022Nif\\u0022:\\u002253739877D\\u0022,\\u0022Cliente\\u0022:\\u002239270\\u0022,\\u0022Nombre\\u0022:\\u00222012 SACH SERVICE, S.L.\\u0022,\\u0022Tabla\\u0022:\\u0022Clientes\\u0022,\\u0022Source\\u0022:\\u0022Odoo\\u0022}\""
```

**Parseado por NestoAPI**: Daba error porque era un string en lugar de JSON

### DESPU√âS (Correcto)

**Mensaje enviado** (una sola serializaci√≥n):
```json
{
  "Accion": "actualizar",
  "Tabla": "Clientes",
  "Datos": {
    "Parent": {
      "Nif": "53739877D",
      "Cliente": "39270",
      "Nombre": "2012 SACH SERVICE, S.L.",
      "Telefono": "666642422",
      "Direccion": "...",
      ...
    },
    "Children": [
      {
        "Nombre": "Juan P√©rez",
        "Email": "juan@example.com",
        "Cargo": "Responsable de Compras"
      }
    ]
  }
}
```

**Parseado por NestoAPI**: ‚úÖ JSON v√°lido que coincide con `ExternalSyncMessageDTO`

---

## üöÄ Pr√≥ximos Pasos

### 1. Desplegar a Producci√≥n (nuevavisionodoo)

El fix est√° en servidor de desarrollo (Odoo18). Hay que sincronizarlo a producci√≥n:

```bash
# En Odoo18 (desarrollo)
cd /opt/odoo16/custom_addons/nesto_sync
git add core/odoo_publisher.py infrastructure/google_pubsub_publisher.py test_publisher_structure.py
git commit -m "fix: Corregir doble serializaci√≥n JSON y estructura de mensaje (Odoo ‚Üí Nesto)"
git push origin main

# En nuevavisionodoo (producci√≥n)
cd /opt/odoo/custom_addons/nesto_sync
git pull origin main

# Limpiar cache
find . -type f -name "*.pyc" -delete

# Actualizar m√≥dulo
python3 odoo-bin -c /opt/odoo/odoo.conf -d [nombre_bd] -u nesto_sync --stop-after-init

# Reiniciar servicio
sudo systemctl restart odoo
```

### 2. Validar en Producci√≥n

Probar el flujo completo:
1. Actualizar un cliente en Odoo UI (cambiar mobile)
2. Verificar logs de Odoo:
   ```bash
   sudo journalctl -u odoo --since '1 minute ago' | grep -E 'üîî|Publicando'
   ```
3. Verificar que NestoAPI recibe el mensaje sin errores
4. Verificar en logs de NestoAPI que el formato es correcto

### 3. Eliminar C√≥digo Temporal de Debug

Una vez confirmado que funciona en producci√≥n, eliminar el c√≥digo temporal con emoji ‚≠ê de `models/res_partner.py`:

```python
# ELIMINAR ESTAS L√çNEAS:
import logging
_logger = logging.getLogger(__name__)

def write(self, vals):
    """Override para debug - verificar que se llama"""
    _logger.info(f"‚≠ê ResPartner.write() llamado con vals: {vals}")
    return super(ResPartner, self).write(vals)
```

---

## üìä Impacto del Fix

### Problemas Resueltos

‚úÖ **Doble serializaci√≥n**: Ahora se serializa solo una vez (en `google_pubsub_publisher.py`)
‚úÖ **Estructura incorrecta**: Ahora usa formato `ExternalSyncMessageDTO` esperado por NestoAPI
‚úÖ **Campos en lugar incorrecto**: `Tabla` ahora est√° en nivel ra√≠z, no en `Parent`
‚úÖ **Children separados**: `PersonasContacto` ahora est√° en `Datos.Children`, no en `Parent`

### Compatibilidad

- ‚úÖ **NestoAPI**: Ahora puede parsear el mensaje sin errores
- ‚úÖ **Sincronizaci√≥n bidireccional**: Funciona correctamente end-to-end
- ‚úÖ **Tests**: Todos los tests existentes siguen pasando

---

## üîß Troubleshooting

### Si sigue llegando formato incorrecto a NestoAPI

1. **Verificar que el c√≥digo est√° actualizado en producci√≥n**:
   ```bash
   cd /opt/odoo/custom_addons/nesto_sync
   git log -1 --oneline
   # Debe mostrar el commit del fix
   ```

2. **Verificar que el m√≥dulo se actualiz√≥**:
   ```bash
   sudo journalctl -u odoo --since '5 minutes ago' | grep "Loading module nesto_sync"
   ```

3. **Limpiar cache de Python**:
   ```bash
   cd /opt/odoo/custom_addons/nesto_sync
   find . -type f -name "*.pyc" -delete
   find . -type d -name __pycache__ -exec rm -rf {} + 2>/dev/null || true
   ```

4. **Verificar logs del publisher**:
   ```bash
   sudo journalctl -u odoo --since '1 minute ago' | grep "Publicando cliente desde Odoo"
   ```

### Si NestoAPI sigue dando errores de parsing

Verificar que el mensaje tiene esta estructura:
```json
{
  "Accion": "actualizar",
  "Tabla": "Clientes",
  "Datos": {
    "Parent": {...},
    "Children": [...]
  }
}
```

Si falta alg√∫n campo, revisar `entity_configs.py` para asegurar que `nesto_table` est√° configurado.

---

## üìö Referencias

- [PROXIMA_SESION.md](PROXIMA_SESION.md) - Gu√≠a de sincronizaci√≥n a producci√≥n
- [ESTADO_DESPLIEGUE.md](ESTADO_DESPLIEGUE.md) - Estado actual del despliegue
- `test_publisher_structure.py` - Tests del formato de mensaje

---

**Sesi√≥n completada**: 2025-11-11
**Fix aplicado**: ‚úÖ Doble serializaci√≥n y estructura de mensaje
**Estado**: Listo para desplegar a producci√≥n
**Pr√≥xima sesi√≥n**: Desplegar a nuevavisionodoo y validar end-to-end
